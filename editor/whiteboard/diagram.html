<!DOCTYPE html>
<html lang="en" class="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UML & Diagram Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --background-light: #f8fafc;
            /* slate-50 */
            --background-dark: #0f172a;
            /* slate-900 */
            --text-light: #0f172a;
            --text-dark: #f8fafc;
            --sidebar-bg-light: #ffffff;
            --sidebar-bg-dark: #1e293b;
            /* slate-800 */
            --canvas-bg-light: #f1f5f9;
            /* slate-100 */
            --canvas-bg-dark: #334155;
            /* slate-700 */
            --border-light: #e2e8f0;
            /* slate-200 */
            --border-dark: #334155;
            --accent-color: #3b82f6;
            /* blue-500 */
            --hover-bg-light: #f1f5f9;
            --hover-bg-dark: #334155;
        }

        html.dark {
            color-scheme: dark;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }

        html.dark body {
            background-color: var(--background-dark);
            color: var(--text-dark);
        }

        .sidebar {
            background-color: var(--sidebar-bg-light);
            border-color: var(--border-light);
        }

        html.dark .sidebar {
            background-color: var(--sidebar-bg-dark);
            border-color: var(--border-dark);
        }

        .canvas-container-wrapper {
            background-color: var(--canvas-bg-light);
        }

        html.dark .canvas-container-wrapper {
            background-color: var(--canvas-bg-dark);
        }

        .toolbar {
            background-color: var(--sidebar-bg-light);
            border-color: var(--border-light);
        }

        html.dark .toolbar {
            background-color: var(--sidebar-bg-dark);
            border-color: var(--border-dark);
        }

        .shape:hover {
            background-color: var(--hover-bg-light);
        }

        html.dark .shape:hover {
            background-color: var(--hover-bg-dark);
        }

        .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .has-tooltip:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        #context-menu {
            display: none;
            position: absolute;
            z-index: 1000;
        }

        .fabric-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .canvas-container {
            position: absolute !important;
        }

        .grid-background {
            background-image:
                linear-gradient(rgba(156, 163, 175, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(156, 163, 175, 0.4) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        html.dark .grid-background {
            background-image:
                linear-gradient(rgba(100, 115, 135, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100, 115, 135, 0.4) 1px, transparent 1px);
        }

        /* Notification Style */
        #notification {
            transform: translateX(calc(100% + 1.25rem));
        }

        #notification.show {
            transform: translateX(0);
        }

        /* Data table styling */
        #data-editor-panel table {
            width: 100%;
            border-collapse: collapse;
        }

        #data-editor-panel th,
        #data-editor-panel td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }

        html.dark #data-editor-panel th,
        html.dark #data-editor-panel td {
            border-bottom: 1px solid var(--border-dark);
        }

        #data-editor-panel th {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #64748b;
            /* slate-500 */
        }

        html.dark #data-editor-panel th {
            color: #94a3b8;
            /* slate-400 */
        }

        #data-editor-panel td {
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100px;
        }

        #data-editor-panel a {
            color: var(--accent-color);
            text-decoration: none;
        }

        #data-editor-panel a:hover {
            text-decoration: underline;
        }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>

<body class="overflow-hidden">
    <div id="app" class="h-screen w-screen flex flex-col">
        <!-- Toolbar -->
        <header class="toolbar border-b shadow-sm p-1 flex items-center justify-between z-20 flex-shrink-0">
            <div class="flex items-center gap-2">
                <div class="p-2 font-bold text-lg flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="text-blue-500">
                        <path
                            d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
                        </path>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    <span>Diagram Pro</span>
                </div>
                <div class="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>
                <button id="home-btn" class="toolbar-btn has-tooltip"
                    onclick="window.location.href='../../home/home.html'">
                    <i data-lucide="home"></i>
                    <span class="tooltip">Home</span>
                </button>
                <button id="new-diagram" class="toolbar-btn has-tooltip"><i data-lucide="file-plus-2"></i><span
                        class="tooltip">New</span></button>
                <button id="export-png" class="toolbar-btn has-tooltip"><i data-lucide="image-down"></i><span
                        class="tooltip">Export PNG</span></button>
                <button id="export-pdf" class="toolbar-btn has-tooltip"><i data-lucide="file-text"></i><span
                        class="tooltip">Export PDF</span></button>
                <button id="save-cloud-btn" class="toolbar-btn has-tooltip"><i data-lucide="cloud-upload"></i><span
                        class="tooltip">Save to Cloud</span></button>
                <div class="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>
                <button id="undo" class="toolbar-btn has-tooltip"><i data-lucide="undo-2"></i><span
                        class="tooltip">Undo</span></button>
                <button id="redo" class="toolbar-btn has-tooltip"><i data-lucide="redo-2"></i><span
                        class="tooltip">Redo</span></button>
            </div>
            <div class="flex items-center gap-2">
                <button id="zoom-out" class="toolbar-btn has-tooltip"><i data-lucide="zoom-out"></i><span
                        class="tooltip">Zoom Out</span></button>
                <span id="zoom-level" class="text-sm w-12 text-center">100%</span>
                <button id="zoom-in" class="toolbar-btn has-tooltip"><i data-lucide="zoom-in"></i><span
                        class="tooltip">Zoom In</span></button>
                <button id="fit-to-screen" class="toolbar-btn has-tooltip"><i data-lucide="maximize"></i><span
                        class="tooltip">Fit to Screen</span></button>
                <div class="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>
                <button id="toggle-data-editor" class="toolbar-btn has-tooltip">
                    <i data-lucide="database"></i>
                    <span class="tooltip">Toggle Data Editor</span>
                </button>
                <button id="theme-toggle" class="toolbar-btn has-tooltip">
                    <i data-lucide="sun" class="light-icon"></i>
                    <i data-lucide="moon" class="dark-icon hidden"></i>
                    <span class="tooltip">Toggle Theme</span>
                </button>
            </div>
        </header>

        <main class="flex flex-1 overflow-hidden">
            <!-- Sidebar -->
            <aside class="sidebar w-60 border-r flex-shrink-0 overflow-y-auto">
                <div id="shape-library">
                    <!-- Shape categories will be injected here -->
                </div>
            </aside>

            <!-- Main Canvas Area -->
            <section id="canvas-wrapper" class="flex-1 flex flex-col relative">
                <div class="canvas-container-wrapper flex-1 relative grid-background overflow-hidden">
                    <canvas id="main-canvas"></canvas>
                </div>
            </section>

            <!-- Properties Panel -->
            <aside id="properties-panel" class="sidebar w-60 border-l flex-shrink-0 overflow-y-auto hidden">
                <div id="text-properties" class="p-4 hidden">
                    <h3 class="text-sm font-bold uppercase text-slate-500 tracking-wider mb-4">Text Properties</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="font-family" class="text-xs text-slate-400">Font</label>
                            <select id="font-family"
                                class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white mt-1">
                                <option>Arial</option>
                                <option>Courier New</option>
                                <option>Georgia</option>
                                <option>Times New Roman</option>
                                <option>Verdana</option>
                            </select>
                        </div>
                        <div>
                            <label for="text-color" class="text-xs text-slate-400">Color</label>
                            <input type="color" id="text-color"
                                class="w-full h-8 p-1 border border-slate-300 dark:border-slate-600 rounded-md cursor-pointer bg-white dark:bg-slate-700">
                        </div>
                        <div>
                            <label for="font-size" class="text-xs text-slate-400">Size</label>
                            <input type="number" id="font-size" min="1" max="200"
                                class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white">
                        </div>
                        <div>
                            <label class="text-xs text-slate-400">Style</label>
                            <div class="grid grid-cols-2 gap-2 mt-1">
                                <button id="font-bold"
                                    class="p-2 border dark:border-slate-700 rounded-md font-bold transition-colors">B</button>
                                <button id="font-italic"
                                    class="p-2 border dark:border-slate-700 rounded-md italic transition-colors">I</button>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Data Editor Panel -->
            <aside id="data-editor-panel" class="sidebar w-80 border-l flex-shrink-0 flex flex-col hidden">
                <div class="p-4 border-b dark:border-slate-700 flex justify-between items-center">
                    <h3 class="text-sm font-bold uppercase text-slate-500 tracking-wider">Data Editor</h3>
                    <button id="refresh-data-btn" class="p-1 rounded hover:bg-slate-200 dark:hover:bg-slate-700">
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                    </button>
                </div>
                <div class="flex-1 overflow-y-auto p-2">
                    <table class="w-full text-left">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Name</th>
                                <th>URL</th>
                            </tr>
                        </thead>
                        <tbody id="diagrams-table-body">
                            <!-- Data will be injected here -->
                            <tr>
                                <td colspan="3" class="text-center p-4 text-slate-500">No data loaded.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </aside>
        </main>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-md shadow-lg text-sm">
        <button data-action="bring-to-front" class="context-menu-item"><i data-lucide="arrow-up-to-line"></i>Bring to
            Front</button>
        <button data-action="bring-forward" class="context-menu-item"><i data-lucide="chevrons-up"></i>Bring
            Forward</button>
        <button data-action="send-backward" class="context-menu-item"><i data-lucide="chevrons-down"></i>Send
            Backward</button>
        <button data-action="send-to-back" class="context-menu-item"><i data-lucide="arrow-down-to-line"></i>Send to
            Back</button>
        <div class="my-1 h-px bg-slate-200 dark:bg-slate-700"></div>
        <button data-action="flip-arrow" class="context-menu-item"><i data-lucide="repeat"></i>Flip Direction</button>
        <button data-action="duplicate" class="context-menu-item"><i data-lucide="copy"></i>Duplicate</button>
        <button data-action="delete" class="context-menu-item text-red-500"><i data-lucide="trash-2"></i>Delete</button>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="modal-title" class="text-lg font-medium leading-6 text-gray-900 dark:text-gray-100">Are you sure?
            </h3>
            <div class="mt-2">
                <p id="modal-message" class="text-sm text-gray-500 dark:text-gray-400">Any unsaved changes will be lost.
                </p>
            </div>
            <div class="mt-4 flex justify-end gap-3">
                <button id="modal-cancel"
                    class="px-4 py-2 bg-gray-200 dark:bg-slate-700 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-slate-600">Cancel</button>
                <button id="modal-confirm"
                    class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Diagram Name Modal -->
    <div id="diagram-name-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-medium leading-6 text-gray-900 dark:text-gray-100">Save to Cloud</h3>
            <div class="mt-2">
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-2">Please enter a name for your diagram.</p>
                <input type="text" id="diagram-name-input"
                    class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white"
                    placeholder="e.g., System Architecture V1">
            </div>
            <div class="mt-4 flex justify-end gap-3">
                <button id="modal-name-cancel"
                    class="px-4 py-2 bg-gray-200 dark:bg-slate-700 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-slate-600">Cancel</button>
                <button id="modal-name-save"
                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>

    <!-- Notification Pop-up -->
    <div id="notification"
        class="fixed bottom-5 right-5 text-white px-4 py-2 rounded-md shadow-lg transition-transform duration-300 z-50">
        <span id="notification-message"></span>
    </div>

    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- SUPABASE INTEGRATION ---
            const SUPABASE_URL = 'https://hehfnsaoibkvwdolcfkg.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhlaGZuc2FvaWJrdndkb2xjZmtnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgxOTc5MDUsImV4cCI6MjA3Mzc3MzkwNX0.aDpemN2HIGpORC-tZiQp0iIqXv7L4tO8zXvDCjygvbs';
            let supabase = null;
            const BUCKET_NAME = 'wike';

            try {
                if (SUPABASE_URL && SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
                    supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    console.log("Supabase client initialized.");
                    fetchAndRenderDiagrams(); // Fetch data on load
                } else {
                    console.warn("Supabase credentials are not set. Cloud features will be disabled.");
                }
            } catch (error) {
                console.error("Error initializing Supabase:", error.message);
            }

            // --- NOTIFICATION UTILITY ---
            const notificationEl = document.getElementById('notification');
            const notificationMessageEl = document.getElementById('notification-message');
            let notificationTimeout;

            const showNotification = (message, isError = false) => {
                clearTimeout(notificationTimeout);
                notificationMessageEl.textContent = message;
                notificationEl.classList.remove('bg-red-500', 'bg-slate-800');
                notificationEl.classList.add(isError ? 'bg-red-500' : 'bg-slate-800');
                notificationEl.classList.add('show');

                notificationTimeout = setTimeout(() => {
                    notificationEl.classList.remove('show');
                }, 3000);
            };

            // --- UTILITY STYLES ---
            const toolbarBtnStyle = 'p-2 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors relative';
            const contextMenuItemStyle = 'w-full px-4 py-2 text-left flex items-center gap-2 hover:bg-slate-100 dark:hover:bg-slate-700';
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.className = toolbarBtnStyle);
            document.querySelectorAll('.context-menu-item').forEach(btn => btn.className = contextMenuItemStyle);
            document.querySelectorAll('.tooltip').forEach(el => {
                el.className = 'tooltip absolute -bottom-8 left-1/2 -translate-x-1/2 bg-slate-800 dark:bg-slate-200 text-white dark:text-black text-xs px-2 py-1 rounded-md whitespace-nowrap';
            });

            lucide.createIcons();

            // --- THEME ---
            const themeToggle = document.getElementById('theme-toggle');
            const lightIcon = document.querySelector('.light-icon');
            const darkIcon = document.querySelector('.dark-icon');
            const docElement = document.documentElement;

            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    docElement.classList.add('dark');
                    docElement.classList.remove('light');
                    lightIcon.classList.add('hidden');
                    darkIcon.classList.remove('hidden');
                } else {
                    docElement.classList.remove('dark');
                    docElement.classList.add('light');
                    darkIcon.classList.add('hidden');
                    lightIcon.classList.remove('hidden');
                }
            };

            const currentTheme = localStorage.getItem('theme') || 'light';
            applyTheme(currentTheme);

            themeToggle.addEventListener('click', () => {
                const newTheme = docElement.classList.contains('dark') ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });

            // --- CANVAS INITIALIZATION ---
            const canvasWrapper = document.querySelector('.canvas-container-wrapper');
            const canvasEl = document.getElementById('main-canvas');
            let canvas = new fabric.Canvas(canvasEl, {
                width: canvasWrapper.clientWidth,
                height: canvasWrapper.clientHeight,
                fireRightClick: true,
                stopContextMenu: true,
            });

            const resizeCanvas = () => {
                canvas.setWidth(canvasWrapper.clientWidth);
                canvas.setHeight(canvasWrapper.clientHeight);
                canvas.renderAll();
            };

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // --- STATE MANAGEMENT (Undo/Redo) ---
            let undoStack = [];
            let redoStack = [];
            let isProcessingState = false;

            const saveState = () => {
                if (isProcessingState) return;
                redoStack = []; // Clear redo stack on new action
                undoStack.push(JSON.stringify(canvas.toDatalessJSON()));
                if (undoStack.length > 30) undoStack.shift(); // Limit history
            };

            const updateState = (state) => {
                isProcessingState = true;
                canvas.loadFromJSON(state, () => {
                    canvas.renderAll();
                    isProcessingState = false;
                });
            };

            document.getElementById('undo').addEventListener('click', () => {
                if (undoStack.length > 1) {
                    const currentState = undoStack.pop();
                    redoStack.push(currentState);
                    const prevState = undoStack[undoStack.length - 1];
                    updateState(prevState);
                }
            });

            document.getElementById('redo').addEventListener('click', () => {
                if (redoStack.length > 0) {
                    const nextState = redoStack.pop();
                    undoStack.push(nextState);
                    updateState(nextState);
                }
            });

            canvas.on('object:modified', saveState);
            canvas.on('object:added', saveState);
            canvas.on('object:removed', saveState);
            saveState(); // Initial state

            // --- CUSTOM ARROW SHAPES ---
            const StraightArrow = fabric.util.createClass(fabric.Line, {
                type: 'arrow',
                initialize: function (element, options) {
                    options || (options = {});
                    this.isDouble = options.isDouble || false;
                    this.callSuper('initialize', element, options);
                },
                toObject: function() {
                    return fabric.util.object.extend(this.callSuper('toObject'), {
                        isDouble: this.isDouble
                    });
                },
                _render: function (ctx) {
                    this.callSuper('_render', ctx);
                    if (this.width === 0 || this.height === 0 || !this.visible) return;
                    const x1 = -this.width / 2, y1 = -this.height / 2, x2 = this.width / 2, y2 = this.height / 2;
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    ctx.save();
                    ctx.translate(x2, y2);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-10, -5);
                    ctx.lineTo(-10, 5);
                    ctx.closePath();
                    ctx.fillStyle = this.stroke;
                    ctx.fill();
                    ctx.restore();

                    if (this.isDouble) {
                        ctx.save();
                        ctx.translate(x1, y1);
                        ctx.rotate(angle + Math.PI);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-10, -5);
                        ctx.lineTo(-10, 5);
                        ctx.closePath();
                        ctx.fillStyle = this.stroke;
                        ctx.fill();
                        ctx.restore();
                    }
                }
            });

            const ElbowArrow = fabric.util.createClass(fabric.Line, {
                type: 'elbow-arrow',
                objectCaching: false,
                 initialize: function (element, options) {
                    options || (options = {});
                    this.flipped = options.flipped || false;
                    this.callSuper('initialize', element, options);
                },
                toObject: function() {
                    return fabric.util.object.extend(this.callSuper('toObject'), {
                        flipped: this.flipped
                    });
                },
                _render: function (ctx) {
                    const x1 = -this.width / 2, y1 = -this.height / 2;
                    const x2 = this.width / 2, y2 = this.height / 2;
                    
                    ctx.beginPath();
                    if (!this.flipped) {
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y1);
                        ctx.lineTo(x2, y2);
                    } else {
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(x1, y2);
                        ctx.lineTo(x1, y1);
                    }
                    
                    ctx.lineWidth = this.strokeWidth;
                    ctx.strokeStyle = this.stroke;
                     if (this.strokeDashArray) {
                        ctx.setLineDash(this.strokeDashArray);
                    }
                    ctx.stroke();
                     if (this.strokeDashArray) { // Reset for arrowhead
                        ctx.setLineDash([]);
                    }

                    // Arrowhead logic
                    let from, to;
                     if (!this.flipped) {
                        from = { x: x2, y: y1 };
                        to = { x: x2, y: y2 };
                    } else {
                        from = { x: x1, y: y2 };
                        to = { x: x1, y: y1 };
                    }
                    
                    const angle = Math.atan2(to.y - from.y, to.x - from.x);
                    ctx.save();
                    ctx.translate(to.x, to.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-10, -5);
                    ctx.lineTo(-10, 5);
                    ctx.closePath();
                    ctx.fillStyle = this.stroke;
                    ctx.fill();
                    ctx.restore();
                }
            });

            const ArcArrow = fabric.util.createClass(fabric.Line, {
                type: 'arc-arrow',
                objectCaching: false,
                initialize: function (element, options) {
                    options || (options = {});
                    this.flipped = options.flipped || false;
                    this.callSuper('initialize', element, options);
                },
                toObject: function() {
                    return fabric.util.object.extend(this.callSuper('toObject'), {
                        flipped: this.flipped
                    });
                },
                _render: function (ctx) {
                    const x1 = -this.width / 2, y1 = -this.height / 2;
                    const x2 = this.width / 2, y2 = this.height / 2;
                   
                    ctx.beginPath();
                    if (!this.flipped) {
                        ctx.moveTo(x1, y1);
                        ctx.quadraticCurveTo(x1, y2, x2, y2);
                    } else {
                        ctx.moveTo(x2, y2);
                        ctx.quadraticCurveTo(x2, y1, x1, y1);
                    }
                    
                    ctx.lineWidth = this.strokeWidth;
                    ctx.strokeStyle = this.stroke;
                    if (this.strokeDashArray) {
                        ctx.setLineDash(this.strokeDashArray);
                    }
                    ctx.stroke();
                    if (this.strokeDashArray) {
                        ctx.setLineDash([]);
                    }

                    // Arrowhead logic
                    let from, to;
                    if (!this.flipped) {
                       from = { x: x1, y: y2 };
                       to = { x: x2, y: y2 };
                    } else {
                       from = { x: x2, y: y1 };
                       to = { x: x1, y: y1 };
                    }
                    
                    const angle = Math.atan2(to.y - from.y, to.x - from.x);
                    ctx.save();
                    ctx.translate(to.x, to.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-10, -5);
                    ctx.lineTo(-10, 5);
                    ctx.closePath();
                    ctx.fillStyle = this.stroke;
                    ctx.fill();
                    ctx.restore();
                }
            });


            // --- SHAPE LIBRARY ---
            const shapeLibrary = document.getElementById('shape-library');
            const shapes = {
                'General': [
                    { name: 'Text', type: 'text', icon: 'type' },
                    { name: 'Rectangle', type: 'rect', icon: 'rectangle-horizontal' },
                    { name: 'Circle', type: 'circle', icon: 'circle' },
                    { name: 'Triangle', type: 'triangle', icon: 'triangle' },
                    { name: 'Diamond', type: 'diamond', icon: 'diamond' },
                ],
                'Connectors & Arrows': [
                    { name: 'Line', type: 'line', icon: 'minus' },
                    { name: 'Arrow', type: 'arrow', icon: 'arrow-up-right' },
                    { name: 'Double Arrow', type: 'double-arrow', icon: 'move' },
                    { name: 'Elbow Arrow', type: 'elbow-arrow', icon: 'corner-up-right' },
                    { name: 'Arc Arrow', type: 'arc-arrow', icon: 'spline' },
                    { name: 'Dashed Arrow', type: 'arrow', icon: 'arrow-up-right', options: { strokeDashArray: [5, 5] } },
                    { name: 'Dashed Elbow', type: 'elbow-arrow', icon: 'corner-up-right', options: { strokeDashArray: [5, 5] } },
                    { name: 'Dashed Arc', type: 'arc-arrow', icon: 'spline', options: { strokeDashArray: [5, 5] } },
                ],
                'Flowchart': [
                    { name: 'Process', type: 'rect', icon: 'rectangle-horizontal', options: { rx: 0, ry: 0, stroke: '#3b82f6', fill: '#dbeafe' } },
                    { name: 'Terminator', type: 'rect', icon: 'rectangle-horizontal', options: { rx: 20, ry: 20, stroke: '#10b981', fill: '#d1fae5' } },
                    { name: 'Decision', type: 'diamond', icon: 'diamond', options: { stroke: '#f59e0b', fill: '#fef3c7' } },
                    { name: 'Data (I/O)', type: 'parallelogram', icon: 'italic', options: { stroke: '#8b5cf6', fill: '#ede9fe' } },
                ],
                'UML': [
                    { name: 'Actor', type: 'actor', icon: 'user-round' },
                    { name: 'Use Case', type: 'ellipse', icon: 'circle-ellipsis', options: { rx: 70, ry: 40, stroke: '#3b82f6', fill: 'white' } },
                    { name: 'Class', type: 'class', icon: 'layout-list' },
                ],
            };

            Object.entries(shapes).forEach(([category, items]) => {
                const categoryEl = document.createElement('div');
                categoryEl.className = 'p-2';
                categoryEl.innerHTML = `<h3 class="text-xs font-bold uppercase text-slate-400 tracking-wider mb-2">${category}</h3>`;
                const gridEl = document.createElement('div');
                gridEl.className = 'grid grid-cols-2 gap-2';

                items.forEach(item => {
                    const shapeEl = document.createElement('div');
                    shapeEl.className = 'shape p-2 border dark:border-slate-700 rounded-md flex flex-col items-center justify-center cursor-pointer text-center';
                    shapeEl.draggable = true;
                    shapeEl.dataset.type = item.type;
                    shapeEl.dataset.options = JSON.stringify(item.options || {});
                    shapeEl.innerHTML = `<i data-lucide="${item.icon}" class="w-8 h-8 mb-1"></i><span class="text-xs">${item.name}</span>`;
                    gridEl.appendChild(shapeEl);
                });
                categoryEl.appendChild(gridEl);
                shapeLibrary.appendChild(categoryEl);
            });
            lucide.createIcons();


            // --- SHAPE CREATION & DRAG-AND-DROP ---
            let draggedShape = null;
            shapeLibrary.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('shape')) {
                    draggedShape = {
                        type: e.target.dataset.type,
                        options: JSON.parse(e.target.dataset.options),
                    };
                }
            });

            canvasWrapper.addEventListener('dragover', (e) => e.preventDefault());

            canvasWrapper.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedShape) {
                    const pointer = canvas.getPointer(e);
                    createShape(draggedShape.type, { ...draggedShape.options, left: pointer.x, top: pointer.y });
                    draggedShape = null;
                }
            });

            const createShape = (type, options = {}) => {
                let shape;
                const defaultOptions = {
                    left: 100, top: 100,
                    fill: '#ffffff', stroke: '#0f172a', strokeWidth: 2,
                    originX: 'center', originY: 'center',
                    cornerColor: '#3b82f6',
                    borderColor: '#3b82f6',
                    transparentCorners: false,
                };
                const finalOptions = { ...defaultOptions, ...options };

                switch (type) {
                    case 'rect':
                        shape = new fabric.Rect({ width: 100, height: 60, ...finalOptions });
                        break;
                    case 'circle':
                        shape = new fabric.Circle({ radius: 40, ...finalOptions });
                        break;
                    case 'triangle':
                        shape = new fabric.Triangle({ width: 80, height: 70, ...finalOptions });
                        break;
                    case 'line':
                        shape = new fabric.Line([0, 0, 100, 0], { ...finalOptions });
                        break;
                    case 'arrow':
                        shape = new StraightArrow([0, 0, 100, 0], { ...finalOptions });
                        break;
                    case 'double-arrow':
                        shape = new StraightArrow([0, 0, 100, 0], { isDouble: true, ...finalOptions });
                        break;
                    case 'elbow-arrow':
                        shape = new ElbowArrow([0, 0, 100, 50], { ...finalOptions });
                        break;
                    case 'arc-arrow':
                        shape = new ArcArrow([0, 0, 100, 50], { ...finalOptions });
                        break;
                    case 'text':
                        shape = new fabric.IText('Your Text', { fontSize: 20, fontWeight: 'normal', fontFamily: 'Arial', ...finalOptions });
                        break;
                    case 'diamond':
                        shape = new fabric.Polygon([
                            { x: 50, y: 0 }, { x: 100, y: 50 }, { x: 50, y: 100 }, { x: 0, y: 50 }
                        ], { ...finalOptions, objectCaching: false });
                        break;
                    case 'parallelogram':
                        shape = new fabric.Polygon([
                            { x: 0, y: 0 }, { x: 120, y: 0 }, { x: 100, y: 50 }, { x: -20, y: 50 }
                        ], { ...finalOptions, width: 120, height: 50 });
                        break;
                    case 'actor':
                        const head = new fabric.Circle({ radius: 15, fill: 'white', stroke: 'black', strokeWidth: 2, top: 0, left: 17.5 });
                        const body = new fabric.Line([32.5, 30, 32.5, 70], { stroke: 'black', strokeWidth: 2 });
                        const arms = new fabric.Line([10, 50, 55, 50], { stroke: 'black', strokeWidth: 2 });
                        const leg1 = new fabric.Line([32.5, 70, 10, 100], { stroke: 'black', strokeWidth: 2 });
                        const leg2 = new fabric.Line([32.5, 70, 55, 100], { stroke: 'black', strokeWidth: 2 });
                        shape = new fabric.Group([head, body, arms, leg1, leg2], { ...finalOptions, objectCaching: false });
                        break;
                    case 'class':
                        const rect = new fabric.Rect({ width: 150, height: 100, fill: 'white', stroke: 'black', strokeWidth: 2 });
                        const line1 = new fabric.Line([0, 35, 150, 35], { stroke: 'black', strokeWidth: 1 });
                        const title = new fabric.IText('ClassName', { top: 8, left: 75, fontSize: 16, textAlign: 'center', originX: 'center' });
                        shape = new fabric.Group([rect, line1, title], { ...finalOptions, subTargetCheck: true });
                        break;
                    case 'ellipse':
                        shape = new fabric.Ellipse({ rx: 60, ry: 35, ...finalOptions });
                        break;
                }
                if (shape) {
                    canvas.add(shape);
                    canvas.setActiveObject(shape);
                    canvas.renderAll();
                }
            };

            // --- MODAL & TOOLBAR ACTIONS ---
            const confirmationModal = document.getElementById('confirmation-modal');
            const modalConfirmBtn = document.getElementById('modal-confirm');
            const modalCancelBtn = document.getElementById('modal-cancel');
            let confirmCallback = null;

            const showConfirmation = (message, onConfirm) => {
                document.getElementById('modal-message').textContent = message;
                confirmationModal.classList.remove('hidden');
                confirmCallback = onConfirm;
            };

            modalConfirmBtn.addEventListener('click', () => {
                if (confirmCallback) confirmCallback();
                confirmationModal.classList.add('hidden');
            });

            modalCancelBtn.addEventListener('click', () => {
                confirmationModal.classList.add('hidden');
                confirmCallback = null;
            });

            document.getElementById('new-diagram').addEventListener('click', () => {
                showConfirmation('Are you sure you want to start a new diagram? Any unsaved changes will be lost.', () => {
                    canvas.clear();
                    undoStack = [];
                    redoStack = [];
                    saveState();
                });
            });

            // Helper function to convert Data URL to Blob
            const dataURLtoBlob = (dataurl) => {
                const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], { type: mime });
            };

            const exportDiagram = async (format) => {
                const originalBg = canvas.backgroundColor;
                canvas.backgroundColor = '#ffffff';
                canvas.renderAll();

                try {
                    if (format === 'pdf') {
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: canvas.width > canvas.height ? 'l' : 'p',
                            unit: 'px',
                            format: [canvas.width, canvas.height]
                        });
                        const imgData = canvas.toDataURL({ format: 'png', quality: 1 });
                        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save("diagram.pdf");
                    } else {
                        const dataUrl = canvas.toDataURL({ format: 'png', quality: 1 });
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = `diagram.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                } finally {
                    canvas.backgroundColor = originalBg;
                    canvas.renderAll();
                }
            };

            document.getElementById('export-png').addEventListener('click', () => exportDiagram('png'));
            document.getElementById('export-pdf').addEventListener('click', () => exportDiagram('pdf'));


            // --- ZOOM & PAN ---
            const zoomLevelEl = document.getElementById('zoom-level');

            const updateZoomLevel = (zoom) => {
                zoomLevelEl.textContent = `${Math.round(zoom * 100)}%`;
            };

            canvas.on('mouse:wheel', function (opt) {
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.01) zoom = 0.01;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateZoomLevel(zoom);
            });

            document.getElementById('zoom-in').addEventListener('click', () => {
                let newZoom = canvas.getZoom() * 1.2;
                canvas.setZoom(newZoom);
                updateZoomLevel(newZoom);
            });
            document.getElementById('zoom-out').addEventListener('click', () => {
                let newZoom = canvas.getZoom() / 1.2;
                canvas.setZoom(newZoom);
                updateZoomLevel(newZoom);
            });
            document.getElementById('fit-to-screen').addEventListener('click', () => {
                canvas.setZoom(1);
                canvas.viewportTransform[4] = 0;
                canvas.viewportTransform[5] = 0;
                canvas.requestRenderAll();
                updateZoomLevel(1);
            });

            canvas.on('mouse:down', function (opt) {
                const evt = opt.e;
                if (evt.altKey === true) {
                    this.isDragging = true;
                    this.selection = false;
                    this.lastPosX = evt.clientX;
                    this.lastPosY = evt.clientY;
                }
            });
            canvas.on('mouse:move', function (opt) {
                if (this.isDragging) {
                    const e = opt.e;
                    const vpt = this.viewportTransform;
                    vpt[4] += e.clientX - this.lastPosX;
                    vpt[5] += e.clientY - this.lastPosY;
                    this.requestRenderAll();
                    this.lastPosX = e.clientX;
                    this.lastPosY = e.clientY;
                }
            });
            canvas.on('mouse:up', function (opt) {
                this.setViewportTransform(this.viewportTransform);
                this.isDragging = false;
                this.selection = true;
            });

            // --- CONTEXT MENU ---
            const contextMenu = document.getElementById('context-menu');
            let contextTarget = null;

            canvas.on('mouse:down', function (opt) {
                if (opt.button === 3) {
                    contextTarget = opt.target;
                    if (contextTarget) {
                        contextMenu.style.left = `${opt.e.clientX}px`;
                        contextMenu.style.top = `${opt.e.clientY}px`;
                        contextMenu.style.display = 'block';

                        const flipButton = contextMenu.querySelector('[data-action="flip-arrow"]');
                        const arrowTypes = ['arrow', 'elbow-arrow', 'arc-arrow'];
                        if (flipButton) {
                            if (arrowTypes.includes(contextTarget.type)) {
                                flipButton.style.display = 'flex';
                            } else {
                                flipButton.style.display = 'none';
                            }
                        }
                    }
                } else {
                    contextMenu.style.display = 'none';
                }
            });

            window.addEventListener('click', () => contextMenu.style.display = 'none');

            contextMenu.addEventListener('click', (e) => {
                const action = e.target.closest('button')?.dataset.action;
                if (action && contextTarget) {
                    let stateShouldBeSaved = false;
                    switch (action) {
                        case 'bring-to-front':
                            canvas.bringToFront(contextTarget);
                            stateShouldBeSaved = true;
                            break;
                        case 'bring-forward':
                            canvas.bringForward(contextTarget);
                            stateShouldBeSaved = true;
                            break;
                        case 'send-backward':
                            canvas.sendBackwards(contextTarget);
                            stateShouldBeSaved = true;
                            break;
                        case 'send-to-back':
                            canvas.sendToBack(contextTarget);
                            stateShouldBeSaved = true;
                            break;
                        case 'flip-arrow':
                            const arrowTypes = ['arrow', 'elbow-arrow', 'arc-arrow'];
                            if (arrowTypes.includes(contextTarget.type)) {
                                if (contextTarget.type === 'arrow') {
                                    // For straight arrows, just swap the coordinates
                                    const { x1, y1, x2, y2 } = contextTarget;
                                    contextTarget.set({ x1: x2, y1: y2, x2: x1, y2: y1 });
                                } else {
                                    // For custom path arrows, toggle a 'flipped' property
                                    contextTarget.set('flipped', !contextTarget.flipped);
                                }
                                stateShouldBeSaved = true;
                            }
                            break;
                        case 'duplicate':
                            contextTarget.clone((cloned) => {
                                cloned.set({
                                    left: cloned.left + 10,
                                    top: cloned.top + 10,
                                });
                                canvas.add(cloned);
                                canvas.setActiveObject(cloned);
                            });
                            // State is saved by object:added event
                            break;
                        case 'delete':
                            if (canvas.getActiveObjects().length > 1) {
                                canvas.getActiveObjects().forEach(obj => canvas.remove(obj));
                            } else {
                                canvas.remove(contextTarget);
                            }
                            canvas.discardActiveObject();
                            // State is saved by object:removed event
                            break;
                    }

                    contextMenu.style.display = 'none';
                    canvas.renderAll();

                    if (stateShouldBeSaved) {
                        saveState();
                    }
                }
            });

            // --- KEYBOARD SHORTCUTS ---
            document.addEventListener('keydown', (e) => {
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.isEditing) return;

                if ((e.key === 'Delete' || e.key === 'Backspace') && activeObject) {
                    if (canvas.getActiveObjects().length > 1) {
                        canvas.getActiveObjects().forEach(obj => canvas.remove(obj));
                    } else {
                        canvas.remove(activeObject);
                    }
                    canvas.discardActiveObject().renderAll();
                    e.preventDefault();
                }

                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') { document.getElementById('undo').click(); e.preventDefault(); }
                    if (e.key === 'y') { document.getElementById('redo').click(); e.preventDefault(); }
                }
            });

            // --- PROPERTIES PANEL ---
            const propertiesPanel = document.getElementById('properties-panel');
            const textProperties = document.getElementById('text-properties');
            const fontFamilySelect = document.getElementById('font-family');
            const textColorInput = document.getElementById('text-color');
            const fontSizeInput = document.getElementById('font-size');
            const fontBoldBtn = document.getElementById('font-bold');
            const fontItalicBtn = document.getElementById('font-italic');

            const getActiveTextObject = (target) => {
                if (!target) return null;
                if (target.type === 'i-text') {
                    return target;
                }
                if (target.type === 'group' && target._objects) {
                    return target._objects.find(obj => obj.type === 'i-text');
                }
                return null;
            };

            const updatePropertiesPanel = () => {
                const activeObject = canvas.getActiveObject();
                const textObject = getActiveTextObject(activeObject);

                if (textObject) {
                    propertiesPanel.classList.remove('hidden');
                    textProperties.classList.remove('hidden');

                    fontFamilySelect.value = textObject.fontFamily || 'Arial';
                    textColorInput.value = new fabric.Color(textObject.fill).toHex();
                    fontSizeInput.value = textObject.fontSize;

                    fontBoldBtn.classList.toggle('bg-blue-500', textObject.fontWeight === 'bold');
                    fontBoldBtn.classList.toggle('text-white', textObject.fontWeight === 'bold');
                    fontItalicBtn.classList.toggle('bg-blue-500', textObject.fontStyle === 'italic');
                    fontItalicBtn.classList.toggle('text-white', textObject.fontStyle === 'italic');

                } else {
                    propertiesPanel.classList.add('hidden');
                    textProperties.classList.add('hidden');
                }
            };

            const applyTextProperty = (prop, value) => {
                const activeObject = canvas.getActiveObject();
                const textObject = getActiveTextObject(activeObject);
                if (textObject) {
                    textObject.set(prop, value);
                    if (activeObject.type === 'group') {
                        activeObject.addWithUpdate();
                    }
                    canvas.renderAll();
                    saveState();
                }
            };

            fontFamilySelect.addEventListener('change', (e) => applyTextProperty('fontFamily', e.target.value));
            textColorInput.addEventListener('input', (e) => applyTextProperty('fill', e.target.value));
            fontSizeInput.addEventListener('input', (e) => {
                const size = parseInt(e.target.value, 10);
                if (!isNaN(size)) {
                    applyTextProperty('fontSize', size);
                }
            });
            fontBoldBtn.addEventListener('click', () => {
                const textObject = getActiveTextObject(canvas.getActiveObject());
                if (textObject) {
                    const isBold = textObject.fontWeight === 'bold';
                    applyTextProperty('fontWeight', isBold ? 'normal' : 'bold');
                    updatePropertiesPanel();
                }
            });
            fontItalicBtn.addEventListener('click', () => {
                const textObject = getActiveTextObject(canvas.getActiveObject());
                if (textObject) {
                    const isItalic = textObject.fontStyle === 'italic';
                    applyTextProperty('fontStyle', isItalic ? 'normal' : 'italic');
                    updatePropertiesPanel();
                }
            });

            canvas.on('selection:created', updatePropertiesPanel);
            canvas.on('selection:updated', updatePropertiesPanel);
            canvas.on('selection:cleared', updatePropertiesPanel);
            canvas.on('text:changed', saveState);

            // --- DATA EDITOR & CLOUD SAVE ---
            const dataEditorPanel = document.getElementById('data-editor-panel');
            const toggleDataEditorBtn = document.getElementById('toggle-data-editor');
            const refreshDataBtn = document.getElementById('refresh-data-btn');
            const diagramsTableBody = document.getElementById('diagrams-table-body');
            const nameModal = document.getElementById('diagram-name-modal');
            const nameInput = document.getElementById('diagram-name-input');
            const saveCloudBtn = document.getElementById('save-cloud-btn');

            toggleDataEditorBtn.addEventListener('click', () => {
                dataEditorPanel.classList.toggle('hidden');
                resizeCanvas();
            });

            refreshDataBtn.addEventListener('click', fetchAndRenderDiagrams);

            async function fetchAndRenderDiagrams() {
                if (!supabase) return;
                try {
                    const { data, error } = await supabase
                        .from('diagrams')
                        .select('*')
                        .order('created_at', { ascending: false });
                    if (error) throw error;
                    renderDiagramsTable(data);
                } catch (error) {
                    console.error('Error fetching diagrams:', error.message);
                    showNotification(`Error fetching data: ${error.message}`, true);
                }
            }

            function renderDiagramsTable(diagrams) {
                diagramsTableBody.innerHTML = '';
                if (diagrams.length === 0) {
                    diagramsTableBody.innerHTML = `<tr><td colspan="3" class="text-center p-4 text-slate-500">No diagrams saved yet.</td></tr>`;
                    return;
                }
                diagrams.forEach(d => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${d.id}</td>
                        <td title="${d.diagram_name}">${d.diagram_name}</td>
                        <td><a href="${d.img_url}" target="_blank" title="${d.img_url}">Link</a></td>
                    `;
                    diagramsTableBody.appendChild(row);
                });
            }

            saveCloudBtn.addEventListener('click', () => {
                if (!supabase) {
                    showNotification('Supabase is not configured.', true);
                    return;
                }
                nameModal.classList.remove('hidden');
                nameInput.focus();
            });

            document.getElementById('modal-name-cancel').addEventListener('click', () => {
                nameModal.classList.add('hidden');
                nameInput.value = '';
            });

            document.getElementById('modal-name-save').addEventListener('click', async () => {
                const diagramName = nameInput.value.trim();
                if (!diagramName) {
                    showNotification('Please enter a diagram name.', true);
                    return;
                }

                const originalBg = canvas.backgroundColor;
                canvas.backgroundColor = '#ffffff';
                canvas.renderAll();

                try {
                    // 1. Prepare data
                    const dataUrl = canvas.toDataURL({ format: 'png', quality: 1 });
                    const blob = dataURLtoBlob(dataUrl);
                    const fileName = `diagrams/diagram-${Date.now()}.png`;

                    showNotification('Uploading to cloud...');

                    // 2. Upload image to Storage
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from(BUCKET_NAME)
                        .upload(fileName, blob);
                    if (uploadError) throw uploadError;

                    // 3. Get public URL
                    const { data: urlData } = supabase.storage
                        .from(BUCKET_NAME)
                        .getPublicUrl(fileName);

                    // 4. Insert record into database table
                    const { error: insertError } = await supabase
                        .from('diagrams')
                        .insert([{ diagram_name: diagramName, img_url: urlData.publicUrl }]);
                    if (insertError) throw insertError;

                    showNotification('Successfully saved to the cloud!');
                    nameModal.classList.add('hidden');
                    nameInput.value = '';
                    fetchAndRenderDiagrams(); // Refresh the table
                } catch (error) {
                    console.error('Cloud save failed:', error.message);
                    showNotification(`Cloud save failed: ${error.message}`, true);
                } finally {
                    // Ensure the background is always reset
                    canvas.backgroundColor = originalBg;
                    canvas.renderAll();
                }
            });

        });
    </script>
</body>

</html>


